{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"Práctica 1\"\n",
        "author: \"Lauro Reyes Rosas - 214532\"\n",
        "format:\n",
        "  html:\n",
        "    code-fold: false\n",
        "jupyter: python3\n",
        "subtitle: \"ITAM - Métodos Numéricos y Optimización (MAT-34420)\"\n",
        "date: \"Fecha de entrega: 2024-10-10\"\n",
        "professor: \"Prof. J. Ezequiel Soto S.\"\n",
        "cache: true\n",
        "---\n",
        "\n",
        "\n",
        "Una función implítica es una función de la forma:\n",
        "$$F(x,y) = 0$$\n",
        "Las funciones implícitas se pueden utilizar para modelar objetos geométricos. Así, un objeto geométrico puede estar definido en términos de $F : \\mathbb{R}^2 \\rightarrow \\mathbb{R}$ como:\n",
        "$$\\mathcal{G} = \\left\\{ (x, y) \\in \\mathbb{R}^2 \\mid F(x, y) \\leq 0 \\right\\} \\subset \\mathbb{R}^2.$$\n",
        "\n",
        "Considera la región $\\mathcal{G}$ determinada por la función:\n",
        "$$F(x,y) = (x^2+y−10)^2+(x+y^2−12)^2 −100$$\n",
        "\n",
        "### Calcular _Bounding Box_\n",
        "\n",
        "Ya que es una función que se puede representar en el plano cartesiano, para calcular el _bounding box_ se hará de forma visual empezando por -10 a 10 ya que AHHHHHH\n"
      ],
      "id": "f22e941f"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "import numpy as np\n",
        "import matplotlib.pyplot as plt\n",
        "import pandas as pd\n",
        "from matplotlib.widgets import Button, Slider\n",
        "from sympy import sign"
      ],
      "id": "c5eb272e",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "**Definimos la función F(x, y)**"
      ],
      "id": "20da082d"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "def F(x, y):\n",
        "    return (x**2 + y - 10)**2 + (x + y**2 - 12)**2 - 100"
      ],
      "id": "d08cc5a1",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "**Creamos gráfica para ver límites**"
      ],
      "id": "51d5c88e"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "x = np.linspace(-10, 10, 200)\n",
        "y = np.linspace(-10, 10, 200)\n",
        "X, Y = np.meshgrid(x, y)\n",
        "# Calcular F en todos los puntos de la malla\n",
        "Z = F(X, Y)\n",
        "# Crear la gráfica \n",
        "plt.figure(figsize=(8, 6))\n",
        "contour = plt.contour(X, Y, Z, levels=[0], colors='red')  # Dibujar el contorno donde F(x, y) = 0\n",
        "plt.clabel(contour, inline=True, fontsize=10)\n",
        "plt.title(r\"Contorno de la función $F(x, y) = 0$\")\n",
        "plt.xlabel(\"X\")\n",
        "plt.ylabel(\"Y\")\n",
        "plt.grid(True)\n",
        "plt.axhline(0, color='black',linewidth=0.5)\n",
        "plt.axvline(0, color='black',linewidth=0.5)\n",
        "plt.show()"
      ],
      "id": "d25e3ca4",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Al ver la gráfica podemos ver que un bounding box correcto, agregando un ligero margen, sería el cuadrado de $x \\in [-6,6]$ y $y \\in [-6,6]$\n",
        "\n",
        "### Estimación de área por Montecarlo\n",
        "La estimación de área por Monte Carlo es un método que usa puntos generados al azar para aproximar el área de una figura. Podemos verlo como lanzar muchos puntos dentro de un rectángulo que rodea la figura. Luego, cuentas cuántos puntos caen dentro de la figura y cuántos fuera. Con esa proporción, multiplicada por el área del rectángulo, puedes calcular el área aproximada de la figura, incluso si su forma es irregular.\n",
        "\n",
        "Primero graficamos cómo se vería esta definición con $10^5$ muestras:"
      ],
      "id": "b15b87f3"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# definimos el bounding box\n",
        "x_min, x_max = -6, 6\n",
        "y_min, y_max = -6, 6\n",
        "bounding_box_area = (x_max - x_min) * (y_max - y_min)\n",
        "# gráfica\n",
        "num_points = 10**5\n",
        "# puntos aleatorios\n",
        "x_random = np.random.uniform(x_min, x_max, num_points)\n",
        "y_random = np.random.uniform(y_min, y_max, num_points)\n",
        "F_values = F(x_random, y_random)\n",
        "# nos quedamos con los valores F(x, y) <= 0\n",
        "points_inside = F_values <= 0\n",
        "area_fraction = np.sum(points_inside) / num_points\n",
        "estimated_area = bounding_box_area * area_fraction\n",
        "# Visualización de los puntos\n",
        "plt.figure(figsize=(8, 8))\n",
        "plt.scatter(x_random, y_random, c=points_inside, s=1)\n",
        "plt.title(f\"Monte Carlo Estimation of Area: {estimated_area:.2f} con $10^5$ muestras\")\n",
        "plt.xlabel(\"x\")\n",
        "plt.ylabel(\"y\")\n",
        "plt.show()"
      ],
      "id": "973f904b",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "después de ver cómo se representa en el plano calculamos el área de $\\mathcal{G}$ usando el método de Monte Carlo con $10^2,10^3,...,10^8$ muestras.\n"
      ],
      "id": "36556572"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "np.random.seed(44)\n",
        "exp = [i for i in range(2,9)]\n",
        "frames = []\n",
        "for i in exp:\n",
        "    num_points = 10**i\n",
        "    x_random = np.random.uniform(x_min, x_max, num_points)\n",
        "    y_random = np.random.uniform(y_min, y_max, num_points)\n",
        "    F_values = F(x_random, y_random)\n",
        "    points_inside = F_values <= 0\n",
        "    # Área estimada\n",
        "    area_fraction = np.sum(points_inside) / num_points\n",
        "    estimated_area = bounding_box_area * area_fraction\n",
        "    # guardar info\n",
        "    frames.append({\"muestras\":num_points,\"area_estimada\":estimated_area})\n",
        "\n",
        "estimated_area_df = pd.DataFrame(frames)\n",
        "estimated_area_df.style.format({\n",
        "    'muestras': '{:.0e}',\n",
        "    'area_estimada': '{:.2f}'\n",
        "})"
      ],
      "id": "0393b2f3",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Vemos que mientras más puntos mejor es nuestra aproximación del área dando un área de **38.77** unidades cuadradas con $10^8$ muestras.\n",
        "\n",
        "### Estimación de área con método recursivo\n",
        "En este caso calculamos el valor de $F(x,y)$ en las esquinas del _bounding box_, en este caso todo va estar fuera de $\\mathcal{G}$ eya que le dimos un margen, y al tener todas las esquinas fuera de $\\mathcal{G}$ se volvera a calcular pero dividiendo el cuadrado en cuatro partes y se volverá a calcular las esquinas hasta llegar a la profundid máxima, una vez que se llega a la profundidad máxima se hará un montecarlo para ajustar el área de es subconjunto que no vamos a volver a dividir.\n"
      ],
      "id": "ba179766"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "def polygon_area(xlims, ylims):\n",
        "    \"\"\"calcula el área de un rectángulo basado en sus coordenadas\"\"\"\n",
        "    b = abs(xlims[1] - xlims[0])\n",
        "    h = abs(ylims[1] - ylims[0])\n",
        "    area = b * h\n",
        "    return area\n",
        "\n",
        "def recursive_plot(fun,xlims,ylims,maxdepth=5):\n",
        "    \"\"\"\n",
        "    Cálculo de área con método recursivo más gráfico explicativo\n",
        "    fun - función implícita\n",
        "    xlims - límites en x, array [xmin, xmax]\n",
        "    ylims - límites en y, array [ymin, ymax]\n",
        "    maxdepth - profundidad máxima de recursión\"\"\"\n",
        "    result = 0\n",
        "    # cálculo montecarlo\n",
        "    n = 1000\n",
        "    x = np.random.uniform(xlims[0], xlims[1], n)\n",
        "    y = np.random.uniform(ylims[0], ylims[1], n)\n",
        "    # cálculo de cuadrado\n",
        "    polyx = np.array([xlims[0], xlims[0], xlims[1], xlims[1], xlims[0]])\n",
        "    polyy = np.array([ylims[0], ylims[1], ylims[1], ylims[0], ylims[0]])\n",
        "    corners = np.array([0,0,0,0])\n",
        "    for i in np.array([0,1]):\n",
        "        for j in np.array([0,1]):\n",
        "            corners[2*i+j] = sign(fun(xlims[i],ylims[j]))\n",
        "\n",
        "    if np.all(np.array(corners) == -1):\n",
        "        # todo el conjunto esta en G\n",
        "        plt.fill( polyx, polyy, color='purple',linewidth=0.5, edgecolor=\"k\")\n",
        "        result += polygon_area(xlims, ylims)\n",
        "    elif np.all(np.array(corners) == 1):\n",
        "        # todo el conjunto está afuera\n",
        "        # revisar si tiene parte de la función\n",
        "        suc = np.sum(fun(x,y) <= 0)\n",
        "        if suc > 0:\n",
        "            # si la función esta en el conjunto subdividir y volver a evaluar\n",
        "            xmid = (xlims[0]+xlims[1])/2\n",
        "            ymid = (ylims[0]+ylims[1])/2\n",
        "            result += recursive_plot(fun,[xlims[0],xmid],[ylims[0],ymid],maxdepth-1)\n",
        "            result += recursive_plot(fun,[xmid,xlims[1]],[ylims[0],ymid],maxdepth-1)\n",
        "            result += recursive_plot(fun,[xlims[0],xmid],[ymid,ylims[1]],maxdepth-1)\n",
        "            result += recursive_plot(fun,[xmid,xlims[1]],[ymid,ylims[1]],maxdepth-1)\n",
        "        else:\n",
        "            # si no hay parte de la función colorear de gris\n",
        "            plt.fill( polyx, polyy,\n",
        "                linewidth=0.5, edgecolor=\"k\", color='gray',alpha=0.4\n",
        "            )\n",
        "    elif maxdepth == 0:\n",
        "        # si llegó a la máxima profundidad terminar con montecarlo\n",
        "        suc = np.sum(fun(x,y) <= 0)\n",
        "        plt.fill( polyx, polyy, color='brown',linewidth=0.5, edgecolor=\"k\")\n",
        "        result += (polygon_area(xlims, ylims) * (suc/n))\n",
        "\n",
        "    else:\n",
        "        # si la función tiene partes en G y otras no subdividir y volver a evaluar\n",
        "        xmid = (xlims[0]+xlims[1])/2\n",
        "        ymid = (ylims[0]+ylims[1])/2\n",
        "        result += recursive_plot(fun,[xlims[0],xmid],[ylims[0],ymid],maxdepth-1)\n",
        "        result += recursive_plot(fun,[xmid,xlims[1]],[ylims[0],ymid],maxdepth-1)\n",
        "        result += recursive_plot(fun,[xlims[0],xmid],[ymid,ylims[1]],maxdepth-1)\n",
        "        result += recursive_plot(fun,[xmid,xlims[1]],[ymid,ylims[1]],maxdepth-1)\n",
        "    return result"
      ],
      "id": "8f0be678",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Graficamos la función donde el morado es los subconjuntos que detecto que pertenecen a $\\mathcal{G}$ y los cafes los aproximo por _montecarlo_."
      ],
      "id": "7934c168"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "np.random.seed(44)\n",
        "fig = plt.figure( figsize=(10,10) )\n",
        "result = recursive_plot(F,[-6,6],[-6,6],7)\n",
        "plt.axis('equal')\n",
        "plt.title(f\"Area = {result:-2f}\")\n",
        "plt.show()"
      ],
      "id": "874dc4ed",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Vemos que el área estimada es muy similar que estimando todo por montecarlo **38.77** unidades cuadradas\n",
        "\n",
        "### Cálculo de probabilidades\n",
        "#### Caso de normal bivariada\n",
        "Calculamos la probabilidad de que un punto aleatorio $(x,y)$ esté en la región $\\mathcal{G}$. \n",
        "Las componentes de $(x, y) \\in \\mathbb{R}^2$ se distribuyen como normal bivariada con medias $\\mu_x,\\mu_y$, desviaciones estándar $\\sigma_x,\\sigma_y$, y correlación $p_{xy}$.\n",
        "$$\\mathbb{P}[(x, y) \\in \\mathcal{G}] =?$$\n",
        "\n",
        "\n",
        "**Integral para calcular esta probabilidad.**\n",
        "\n",
        "La función de densidad conjunta de la distribución normal bivariada es\n",
        "$$\n",
        "f(x, y) = \\frac{1}{2\\pi\\sigma_X\\sigma_Y\\sqrt{1-\\rho^2}} \\exp \\left( -\\frac{1}{2(1-\\rho^2)} \\left[ \\frac{(x-\\mu_X)^2}{\\sigma_X^2} + \\frac{(y-\\mu_Y)^2}{\\sigma_Y^2} - 2\\rho\\frac{(x-\\mu_X)(y-\\mu_Y)}{\\sigma_X\\sigma_Y} \\right] \\right)\n",
        "$$\n",
        "\n",
        "Dando un integral de\n",
        "\n",
        "$$\n",
        "\\mathbb{P}[(x,y) \\in \\mathcal{G}] = \\iint_{\\mathcal{G}} \\frac{1}{2\\pi\\sigma_X\\sigma_Y\\sqrt{1-\\rho^2}} \\exp \\left( -\\frac{1}{2(1-\\rho^2)} \\left[ \\frac{(x-\\mu_X)^2}{\\sigma_X^2} + \\frac{(y-\\mu_Y)^2}{\\sigma_Y^2} - 2\\rho\\frac{(x-\\mu_X)(y-\\mu_Y)}{\\sigma_X\\sigma_Y} \\right] \\right) \\, dx \\, dy\n",
        "$$\n",
        "\n",
        "**Montecarlo**: En este caso por la complejidad de la integral podemos usar Montecarlo para estimar el valor de $\\mathcal{G}$, para esto se generan múltiples muestras $(x,y)$ con la distribución normal bivariada especificada (con medias $\\mu_x,\\mu_y$, desviaciones estándar $\\sigma_x,\\sigma_y$​, y correlación $p_{xy}$​). Luego, se evalúa la función $F(x,y)$ para determinar si cada muestra cae dentro de la región $\\mathcal{G}$. La probabilidad se estima como la proporción de muestras que cumplen $F(x,y)≤0$ respecto al total de muestras generadas.\n",
        "\n",
        "Calculamos montecarlo con muestras $10^2, 10^3, . . . , 10^8$ suponiendo que las componentes de $(x, y) \\in \\mathbb{R}^2$ se distribuyen como normal bivariada con $\\mu_x = \\mu_y \\in \\{−6, −5, . . . , 5, 6\\}$, $\\sigma_x = \\sigma_y \\in \\{1,2,3,4,5\\}$ y $p_{xy} = 0$\n"
      ],
      "id": "c96e4650"
    },
    {
      "cell_type": "code",
      "metadata": {
        "cache": true
      },
      "source": [
        "def calcular_probabilidad_region(N, mu_x, mu_y, sigma_x, sigma_y, p_xy, F):\n",
        "    \"\"\"\n",
        "    Calcula la probabilidad de que (x, y) esté en la región G utilizando Monte Carlo.\n",
        "\n",
        "    Args:\n",
        "        N (int): Número de muestras aleatorias a generar.\n",
        "        mu_x (float): Media de la distribución en el eje x.\n",
        "        mu_y (float): Media de la distribución en el eje y.\n",
        "        sigma_x (float): Desviación estándar en el eje x.\n",
        "        sigma_y (float): Desviación estándar en el eje y.\n",
        "        p_xy (float): Correlación entre x e y.\n",
        "        F (function): Función que define la región G (retorna True si está en la región).\n",
        "\n",
        "    Returns:\n",
        "        float: Probabilidad estimada de que (x, y) esté en la región G.\n",
        "    \"\"\"\n",
        "    # Matriz de covarianza para la normal bivariada\n",
        "    cov_matrix = [[sigma_x**2, p_xy * sigma_x * sigma_y],\n",
        "                  [p_xy * sigma_x * sigma_y, sigma_y**2]]\n",
        "    \n",
        "    # Generar N muestras aleatorias de la normal bivariada\n",
        "    muestras = np.random.multivariate_normal([mu_x, mu_y], cov_matrix, N)\n",
        "    \n",
        "    return np.sum(np.array(F(muestras[:, 0], muestras[:, 1])) <= 0) / len(muestras)\n",
        "\n",
        "mus = np.arange(-6, 7, 1)    # Medias mu_x y mu_y de -6 a 6\n",
        "sigmas = [1, 2, 3, 4, 5]     # Desviaciones estándar sigma_x y sigma_y\n",
        "p_xy = 0                     # Correlación entre x e y\n",
        "N_values = [10**i for i in range(2, 9)]  # Valores de N = 10^2, 10^3, ..., 10^8\n",
        "\n",
        "# DataFrame para guardar los resultados\n",
        "frames = list()\n",
        "\n",
        "# Calcular la probabilidad para cada combinación de parámetros\n",
        "for mu_x in mus:\n",
        "    mu_y = mu_x\n",
        "    for sigma_x in sigmas:\n",
        "        sigma_y = sigma_x  # Igualar sigma_x y sigma_y\n",
        "        for N in N_values:\n",
        "            probabilidad = calcular_probabilidad_region(N, mu_x, mu_y, sigma_x, sigma_y, p_xy, F)\n",
        "            frames.append({\"N\":N, \"mu_x\":mu_x, \"mu_y\":mu_y, \"sigma_x\":sigma_x, \n",
        "                           \"sigma_y\":sigma_y, \"probabilidad\":probabilidad})"
      ],
      "id": "10dbfa18",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "##### Distribuciones con mayor probabilidad\n",
        "Vemos que las distribuciones con mayor probabilidad son "
      ],
      "id": "b7a1c6ed"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "top_probs = (\n",
        "    pd.DataFrame(frames)\n",
        "    .sort_values('probabilidad',ascending=False)\n",
        "    .drop_duplicates(subset=['mu_x','mu_y','sigma_x','sigma_y'])\n",
        "    .head(4)\n",
        ")\n",
        "top_probs.style.format({\n",
        "    'probabilidad': '{:.4f}',\n",
        "    'N': '{:.1e}'\n",
        "})"
      ],
      "id": "aeae5de1",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Y graficamos comparando con la $F(x,y)$\n"
      ],
      "id": "2982fb90"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "def plot_bivariate_gaussian(mu_x, mu_y, sigma_x, sigma_y, N, p_xy=0):\n",
        "    \"\"\"\n",
        "    Genera y grafica muestras aleatorias de una distribución normal bivariada con los parámetros especificados.\n",
        "    \n",
        "    Args:\n",
        "        mu_x (float): Media de la variable X.\n",
        "        mu_y (float): Media de la variable Y.\n",
        "        sigma_x (float): Desviación estándar de la variable X.\n",
        "        sigma_y (float): Desviación estándar de la variable Y.\n",
        "        N (int): Número de muestras aleatorias a generar.\n",
        "        p_xy (float): Correlación entre X y Y. Por defecto es 0 (independientes).\n",
        "\n",
        "    Returns:\n",
        "        None\n",
        "    \"\"\"\n",
        "    # Matriz de covarianza para la normal bivariada\n",
        "    cov_matrix = [[sigma_x**2, p_xy * sigma_x * sigma_y],\n",
        "                  [p_xy * sigma_x * sigma_y, sigma_y**2]]\n",
        "\n",
        "    # Generar N muestras aleatorias de la normal bivariada\n",
        "    muestras = np.random.multivariate_normal([mu_x, mu_y], cov_matrix, N)\n",
        "\n",
        "    # Crear la gráfica\n",
        "    plt.contour(X, Y, Z, levels=[0], colors='red')  # Dibujar el contorno donde F(x, y) = 0\n",
        "    plt.scatter(muestras[:, 0], muestras[:, 1], color='blue', s=10, alpha=.2)\n",
        "    plt.xlim(-10, 10)\n",
        "    plt.ylim(-10, 10)\n",
        "    plt.axhline(0, color='black', linewidth=1)\n",
        "    plt.axvline(0, color='black', linewidth=1)\n",
        "    plt.title(f\"N={N}, μ=({mu_x}, {mu_y}), σ=({sigma_x}, {sigma_y}), p={p_xy}\")\n",
        "    plt.xlabel(\"Eje X\")\n",
        "    plt.ylabel(\"Eje Y\")\n",
        "    plt.grid(True)"
      ],
      "id": "dd40272d",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "params = top_probs.drop(columns=['probabilidad']).values\n",
        "fig, axes = plt.subplots(2, 2, figsize=(10, 10))\n",
        "for (i, ax), param in zip(enumerate(axes.flatten()), params):\n",
        "    N, mu_x, mu_y, sigma_x, sigma_y = param\n",
        "    plt.sca(ax)\n",
        "    # función para hacer subplot con los puntos de la distribución \n",
        "    # bivariada y F\n",
        "    plot_bivariate_gaussian(mu_x, mu_y, sigma_x, sigma_y, N)\n",
        "\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ],
      "id": "07e4afb4",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "##### Distribuciones con menor probabilidad\n"
      ],
      "id": "28e13a51"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "low_probs = (\n",
        "    pd.DataFrame(frames)\n",
        "    .sort_values('probabilidad')\n",
        "    .drop_duplicates(subset=['mu_x','mu_y','sigma_x','sigma_y'])\n",
        "    .head(4)\n",
        ")\n",
        "low_probs.style.format({\n",
        "    'probabilidad': '{:.4f}',\n",
        "    'N': '{:.1e}'\n",
        "})"
      ],
      "id": "9e19070d",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "params = low_probs.drop(columns=['probabilidad']).values\n",
        "fig, axes = plt.subplots(2, 2, figsize=(10, 10))\n",
        "for (i, ax), param in zip(enumerate(axes.flatten()), params):\n",
        "    N, mu_x, mu_y, sigma_x, sigma_y = param\n",
        "    plt.sca(ax)\n",
        "    # función para hacer subplot con los puntos de la distribución \n",
        "    # bivariada y F\n",
        "    plot_bivariate_gaussian(mu_x, mu_y, sigma_x, sigma_y, N)\n",
        "\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ],
      "id": "df32f681",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "##### Interpretación\n",
        "A pesar de que la probabilidad máxima con una distribución normal bivariada es \n",
        "$$\\mathbb{P}\\left[(x, y) \\in \\mathcal{G} \\mid (x, y) \\sim \\mathcal{N}(\\mu_{xy}, \\Sigma)\\right] = 0.76,$$ \n",
        "esta aproximación no es muy confiable, ya que la región cubierta por la distribución es pequeña y se concentra solo en una parte específica de $\\mathcal{G}$. En contraste, aunque la probabilidad con una distribución uniforme es menor, \n",
        "$$\\mathbb{P}\\left[(x, y) \\in \\mathcal{G} \\mid (x, y) \\sim \\mathcal{U}(-6, 6) \\times \\mathcal{U}(-6, 6)\\right] = 0.27,$$ \n",
        "esta distribución cubre toda el área de $\\mathcal{G}$, lo que resulta en una mejor estimación del área de $F(x, y)$, ya que no se limita a una región específica.\n"
      ],
      "id": "1a54acc4"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "/opt/anaconda3/share/jupyter/kernels/python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}